// Integer.highestOneBit 用于计算大于等于传入int且最小的2的n次幂的数
public static int highestOneBit(int i) {
    i |= (i >>  1);
    i |= (i >>  2);
    i |= (i >>  4);
    i |= (i >>  8);
    i |= (i >> 16);
    return i - (i >>> 1);
}


    /**
     * Returns a power of two table size for the given desired capacity.
     * See Hackers Delight, sec 3.2
     */
    //Integer.highestOneBit用来求高位的1
    //此函数用来求最小且比传入参数大的2的n次方  
    private static final int tableSizeFor(int c) {
        int n = c - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }


    
// static class Node<K,V> implements Map.Entry<K,V> 
// 内部类的成员函数
final int hash;
final K key;
volatile V val;
volatile Node<K,V> next;

/* ---------------- Fields -------------- */

    /**
     * The array of bins. Lazily initialized upon first insertion.
     * Size is always a power of two. Accessed directly by iterators.
     */
    //键值对桶数组
    transient volatile Node<K,V>[] table;

    /**
     * The next table to use; non-null only while resizing.
     */
    // rehash扩容时用到的新键值对数组
    private transient volatile Node<K,V>[] nextTable;

    /**
     * Base counter value, used mainly when there is no contention,
     * but also as a fallback during table initialization
     * races. Updated via CAS.
     */
    //记录当前键值对总数，通过CAS更新，对所有线程可见
    private transient volatile long baseCount;

    /**
     * Table initialization and resizing control.  When negative, the
     * table is being initialized or resized: -1 for initialization,
     * else -(1 + the number of active resizing threads).  Otherwise,
     * when table is null, holds the initial table size to use upon
     * creation, or 0 for default. After initialization, holds the
     * next element count value upon which to resize the table.
     */
    // 表为空,保存表初始大小,或者默认0
    // 初始化后为0.75n,n为table大小
    //-1,表示正在初始化
    // -n(n>1)  使用了一种生成戳，根据生成戳算出一个基数，不同轮次的扩容操作的生成戳都是唯一的，来保证多次扩容之间不会交叉重叠
    private transient volatile int sizeCtl;

    /**
     * The next table index (plus one) to split while resizing.
     */
    private transient volatile int transferIndex;

    /**
     * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.
     */
    private transient volatile int cellsBusy;

    /**
     * Table of counter cells. When non-null, size is a power of 2.
     */
    private transient volatile CounterCell[] counterCells;

    // views
    private transient KeySetView<K,V> keySet;
    private transient ValuesView<K,V> values;
    private transient EntrySetView<K,V> entrySet;


    // 之前版本是每个Segment都持有一把锁，1.8版本改为锁住恰好装在一个hash桶本身位置上的节点，
    // 也就是hash桶的第一个节点 tabAt(table, i)
    /** Implementation for put and putIfAbsent */
    final V putVal(K key, V value, boolean onlyIfAbsent) {
        if (key == null || value == null) throw new NullPointerException();
        int hash = spread(key.hashCode());
        int binCount = 0;
        //存在一个for循环
        //表空初始化;相应的hash桶为空就建造相应的桶,插入键值后跳出循环;插入新结点或者更新旧值就死循环
        for (Node<K,V>[] tab = table;;) {
            Node<K,V> f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0)
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                if (casTabAt(tab, i, null,
                             new Node<K,V>(hash, key, value, null)))//cas->本地方法->硬件实现->乐观锁->仅在更新旧值返回true(tab[i]是否等于value)
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        if (fh >= 0) {
                            binCount = 1;
                            for (Node<K,V> e = f;; ++binCount) {
                                K ek;
                                if (e.hash == hash &&
                                    ((ek = e.key) == key ||
                                     (ek != null && key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node<K,V> pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node<K,V>(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        else if (f instanceof TreeBin) {
                            Node<K,V> p;
                            binCount = 2;
                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    if (binCount >= TREEIFY_THRESHOLD)
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        addCount(1L, binCount);
        return null;
    }


/**
     * The bin count threshold for using a tree rather than list for a
     * bin.  Bins are converted to trees when adding an element to a
     * bin with at least this many nodes. The value must be greater
     * than 2 and should be at least 8 to mesh with assumptions in
     * tree removal about conversion back to plain bins upon
     * shrinkage.
     */
    static final int TREEIFY_THRESHOLD = 8;// 一个hash桶中hash冲突的数目大于此值时，把链表转化为红黑树，加快hash冲突时的查找速度  


    /**
     * The bin count threshold for untreeifying a (split) bin during a
     * resize operation. Should be less than TREEIFY_THRESHOLD, and at
     * most 6 to mesh with shrinkage detection under removal.
     */
    static final int UNTREEIFY_THRESHOLD = 6;// 一个hash桶中hash冲突的数目小于等于此值时，把红黑树转化为链表，当数目比较少时，链表的实际查找速度更快，也是为了查找效率  


    /**
     * The smallest table capacity for which bins may be treeified.
     * (Otherwise the table is resized if too many nodes in a bin.)
     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts
     * between resizing and treeification thresholds.
     */
    static final int MIN_TREEIFY_CAPACITY = 64;// 当table数组的长度小于此值时，不会把链表转化为红黑树。所以转化为红黑树有两个条件，还有一个是 TREEIFY_THRESHOLD  



// 红黑树节点TreeNode实际上还保存有链表的指针，因此也可以用链表的方式进行遍历读取操作  
// 自身维护一个简单的读写锁，不用考虑写-写竞争的情况  
// 不是全部的写操作都要加写锁，只有部分的put/remove需要加写锁  
// 很多方法的实现和jdk1.8的ConcurrentHashMap.TreeNode里面的方法基本一样，可以互相参考  
static final class TreeBin<K,V> extends Node<K,V> {  
    TreeNode<K,V> root; // 红黑树结构的跟节点  
    volatile TreeNode<K,V> first; // 链表结构的头节点  
    volatile Thread waiter; // 最近的一个设置 WAITER 标识位的线程  
    volatile int lockState; // 整体的锁状态标识位  

    
    
    //静态内部类static final class TreeBin<K,V> extends Node<K,V>

    // 可能会阻塞写线程，当写线程获取到写锁时，才会返回  
    // ConcurrentHashMap的put/remove/replace方法本身就会锁住TreeBin节点，这里不会出现写-写竞争的情况  
    // 本身这个方法就是给写线程用的，因此只用考虑 读锁 阻碍线程获取 写锁，不用考虑 写锁 阻碍线程获取 写锁，  
    //     这个读写锁本身实现得很简单，处理不了写-写竞争的情况  
    // waiter要么是null，要么是当前线程本身  

    // values for lockState  
    // 二进制001，红黑树的 写锁状态  
    static final int WRITER = 1; // set while holding write lock  
    // 二进制010，红黑树的 等待获取写锁的状态，中文名字太长，后面用 WAITER 代替  
    static final int WAITER = 2; // set when waiting for write lock  
    //   
    static final int READER = 4; // increment value for setting read lock 
    private final void contendedLock() {  
        boolean waiting = false;  
        for (int s;;) {  
            // ~WAITER是对WAITER进行二进制取反，当此时没有线程持有 读锁（不会有线程持有 写锁）时，这个if为真  
            if (((s = lockState) & ~  WAITER  ) == 0) {  //lockState为0,当前线程未持有读锁
                if (U.compareAndSwapInt(this, LOCKSTATE, s, WRITER)) {  
                    // 在 读锁、写锁 都没有被别的线程持有时，尝试为自己这个写线程获取 写锁，同时清空 WAITER 状态的标识位  
                    if (waiting) // 获取到写锁时，如果自己曾经注册过 WAITER 状态，将其清除  
                        waiter = null;  
                    return;  
                }  
            }  
            else if ((s & WAITER) == 0) { // 有线程持有 读锁（不会有线程持有 写锁），并且当前线程不是 WAITER 状态时，这个else if为真  
                if (U.compareAndSwapInt(this, LOCKSTATE, s, s | WAITER)) { // 尝试占据 WAITER 状态标识位  
                    waiting = true; // 表明自己正处于 WAITER 状态，并且让下一个被用于进入下一个 else if  
                    waiter = Thread.currentThread();  
                }  
            }  
            else if (waiting) // 有线程持有 读锁（不会有线程持有 写锁），并且当前线程处于 WAITER 状态时，这个else if为真  
                LockSupport.park(this); // 阻塞自己  
        }  
    }  



    // 从根节点开始遍历查找，找到“相等”的节点就返回它，没找到就返回null  
    // 当有写线程加上 写锁 时，使用链表方式进行查找  
    final Node<K,V> find(int h, Object k) {  
        if (k != null) {  
            for (Node<K,V> e = first; e != null; ) {  
                int s; K ek;  
                // 两种特殊情况下以链表的方式进行查找  
                // 1、有线程正持有 写锁，这样做能够不阻塞读线程  
                // 2、WAITER时，不再继续加 读锁，能够让已经被阻塞的写线程尽快恢复运行，或者刚好让某个写线程不被阻塞  
                if (((s = lockState) & (WAITER|WRITER)) != 0) {  
                    if (e.hash == h && ((ek = e.key) == k || (ek != null && k.equals(ek))))  
                        return e;  
                    e = e.next;  
                }  
                else if (U.compareAndSwapInt(this, LOCKSTATE, s, s + READER)) { // 读线程数量加1，读状态进行累加  
                    TreeNode<K,V> r, p;  
                    try {  
                        p = ((r = root) == null ? null : r.findTreeNode(h, k, null));  
                    } finally {  
                        Thread w;  
                        // 如果这是最后一个读线程，并且有写线程因为 读锁 而阻塞，那么要通知它，告诉它可以尝试获取写锁了  
                        // U.getAndAddInt(this, LOCKSTATE, -READER)这个操作是在更新之后返回lockstate的旧值，  
                        //     不是返回新值，相当于先判断==，再执行减法  
                        if (U.getAndAddInt(this, LOCKSTATE, -READER) == (READER|WAITER) && (w = waiter) != null)  
                            LockSupport.unpark(w); // 让被阻塞的写线程运行起来，重新去尝试获取 写锁  
                    }  
                    return p;  
                }  
            }  
        }  
        return null;  
    }  