一 数据和界面的交互
1 新闻,视频,个人设置信息3个模块使用3个Fragment,使用底部栏切换相应Fragment
2 进入新闻模块NewsModuleFragment
1)静态内部类ViewPagerTopTab
a 每个Tab创建相应的下拉刷新Fragment
b Tab文字,图片,分割线颜色数据存在静态内部类中
c 每个tab对应一个这个静态内部类的实例,用ArrayList存储

2) P层替代Activity执行Tab数据的初始化,XXX的初始化

3) FragmentStatePagerAdapter 
a FragmentStatePagerApdapter和FragmentPagerAdapter的比较(即为什么要用前者)
共同点:当Adapter需要指定位置的Fragment,Fragment不存在,getItem会被调用。getItem执行的任务是是创建Fragment
区别：
前者当Fragment销毁，getItem就会被调用；彻底销毁Fragment，并把实例状态存在Bundle中，生成新Fragment时用于数据恢复
后者销毁Fragment的视图后，fragment实例保留在FM中不被销毁，也因此不再调用getItem
b getItem中使用对应的Tab数据类创建对应的Fragment，让适配器得知这个数据
c 各类Adapter的notifydatasetChange的工作原理，待继续研究

//
1 findViewbyId写在onCreateView还是onViewCreated


二
1 每个tab的主题
创建对应的Fragment,从全局Application获取对应得数据源URL。ViewPagerAdapter已经有相应的缓存和调用机制，不需要自己收集Fragment到某个容器中。
2 每个Fragment
实现了下拉刷新功能

三 Activity和Fragment的状态缓存策略,以及最佳实践
1 当 Activity 的 onSaveInstanceState 方法被调用时，Activity 会自动收集 Viewde的视图层次
一旦 onRestoreInstanceState 方法被调用，Activity 将这些收集的数据回传给视图层次中的View
2 视图层次中的View可以，Activity成员变量不行
3 自定义View的缓存和恢复；换句话能时缓存策略生效的条件：
重写View的onSaveInstanceState：造一个Bundle，
重写View的onRestoreInstanceState：调用父类方法+取出Parcelable状态
View在Layout文件中有分配android:id属性
4 自定义Fragment的缓存策略：
在Fragment重写onSaveInstanceState,利用Bundle参数存数据
5 综合第4,5点,View重写对应方法实现缓存,Fragment也重写对应方法缓存其他剩余的数据

四 下拉刷新原理SwipeMenuRecyclerView+SwipeRefreshLayout

五 重构SharedPreferences
